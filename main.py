# Сеть Фейштеля
# Количество раундов: 10
# Образующая функция: исключающее ИЛИ |^ XOR
import textwrap

def crypt(string, key):  #на вход поступает исходная строка и ключ

    #преобразовываем входную строку в бинарный код
    string2 = ""
    for s in string:
        string2 += '{0:08b}'.format(ord(s))
    print("Исходный бинарный код входного сообщения: ", string2)

    # длина ключа == длине подблока
    if len(key)!=24:
        print("Убедитесь в том, что длинна ключа равна 24м битам!")

    # разбиваем строку на равные подблоки / Left Right (24 бита == 3 символа)
    n = 24
    subblock = [string2[i:i + n] for i in range(0, len(string2), n)]

    #собираем подблоки в блоки по 48 бит (6 символов / 2 подблока L&R)
    n=2
    block = [subblock[i:i + n] for i in range(0, len(subblock), n)]
    print("Входные бинарные блоки и их подблоки: ", block)

    cryp_st = ''
    cryp_new_st = ''
    cryp_xor_st = ''
    b = 0
    for s in block: # перебираем блоки
        # цикл 10раундового шифрования для каждого из блоков
        for t in range(9):
            print("\nРАУНД №", t)
            i = 0 # первый L подблок 24 бит
            # работаем с первым подблоком (все операции осуществляем через L = block[s][0] / R = block[s][1])
            sl = ''
            sl =''.join(str(block[b][i]))
            # X = L ксорим с ключем
            for bin,k in zip(sl, key):
                cryp_st += str(int(bin)^int(k))
            r = '{0:024b}'.format(ord(str(t))) # номер раунда 24bit
            print("raund", r)
            print("cryp_st", cryp_st)
            # X ксорим с номером раунда
            for cr, raund in zip(cryp_st, r):
                # X = L ксорим с ключем
                cryp_new_st += str(int(cr) ^ int(raund))
            print("cryp_new_st", cryp_new_st)

            print('\nL подблок прошел первую итерацию X, "кодирование с ключом"')

            # (X / cryp_st) ксорим с Right subblock 24 бит
            sr = ''
            sr = ''.join(str(block[b][i+1]))
            for sx,xor in zip(cryp_new_st, sr):
                cryp_xor_st += str(int(sx)^int(xor))
            print('L подблок прошел вторую итерацию, "кодирование с правым подблоком"')
            print("cryp_xor_st", cryp_xor_st)
            # Исходный R подблок меняем местами с X(L) подблоком
            block[b][i-1]= block[b][i]
            block[b][i]=cryp_xor_st
            cryp_st = ''
            cryp_new_st = ''
            print("L подблок закодирован! L и R обменялись позициями!", cryp_xor_st)
            cryp_xor_st = ''
        print('\nБЛОК ', b, ' ЗАКОДИРОВАН! >>>', s, '\nПЕРЕХОД К СЛЕДУЮЩЕМУ БЛОКУ...\n')
        b +=1 # переход на новый блок





def decrypt(string, key): # на вход пуступает: 2 блока в каждом из которых 2 подблока. ключ

    # длина ключа == длине подблока
    if len(key) != 24:
        print("Убедитесь в том, что длинна ключа равна 24м битам!")

    # разбиваем строку на равные подблоки / Left Right (24 бита == 3 символа)
    n = 24
    subblock = [string[i:i + n] for i in range(0, len(string), n)]

    # собираем подблоки в блоки по 48 бит (6 символов / 2 подблока L&R)
    n = 2
    block = [subblock[i:i + n] for i in range(0, len(subblock), n)]
    print("Входные закодированные бинарные блоки и их подблоки: ", block)

    decryp_st = ''
    decryp_new_st = ''
    block1 = ''
    encrypt = []
    b = 0
    for s in block:  # перебираем блоки
        # цикл 10раундового дешифрования для каждого из блоков
        for t in range(9):
            print("\nРАУНД №", t)
            i = 0  # первый L подблок 24 бит
            # работаем с первым подблоком (все операции осуществляем через L = block[s][0] / R = block[s][1])
            sl = ''.join(str(block[b][i]))

            # crypt:
            # block1 ^ key = X
            # X ^ №r = X1
            # X1 ^ block2 = X2

            # decrypt:
            # X1 = block2 ксорим с X2
            # X = X1 ксорим с номером раунда
            # block1 = X ксорим с ключом

            # X1 = block2 ксорим с X2
            # (X / cryp_st) ксорим с Right subblock 24 бит
            sr = ''
            sr = ''.join(str(block[b][i+1]))
            for sx, xor in zip(sl, sr):
                decryp_new_st += str(int(sx) ^ int(xor))
            print('L подблок прошел первую итерацию X1, "декодирование с правым подблоком"')

            # X = X1 ксорим с номером раунда
            r = '{0:024b}'.format(ord(str(t)))  # номер раунда 24bit
            for cr, raund in zip(decryp_new_st, r):
                decryp_st += str(int(cr) ^ int(raund))
            print('\nL подблок прошел вторую итерацию X, "декодирование с ключом"')

            # block1 = X ксорим с ключом
            for bin, k in zip(decryp_st, key):
                block1 += str(int(bin) ^ int(k))
            print('\nL подблок прошел третью итерацию block1, "декодирование с ключом"')
            # test
            # print('raund', r)
            # print('sr decryp_xor_st ', sr)
            # print("block1", block1)
            # print("decryp_st", decryp_st)
            # print("decryp_new_st", decryp_new_st)
            # Раскодированный L подблок меняем местами с X(L) подблоком
            block[b][i + 1] = block[b][i]
            block[b][i] = block1
            decryp_st = ''
            decryp_new_st = ''
            sl = ''
            print("L подблок раскодирован! L и R обменялись позициями!", block1)
            block1 = ''
        print('\nБЛОК ', b, ' РАСКОДИРОВАН! >>>', s, '\nПЕРЕХОД К СЛЕДУЮЩЕМУ БЛОКУ...\n')
        b += 1  # переход на новый блок
        encrypt += s

    # воссоздаем исходную картину, разбираем бинарный код подблоков, расшифровываем символы (по 8bit)
    z = []
    c = ''
    for g in encrypt:
        z += textwrap.wrap(g, 8)
    for x in z:
        c += chr(int(x, 2))
    print('СООБЩЕНИЕ РАСШИФРОВАНО!\n\n','Исходный текст: ', c,'\n')
def main():

    print("Выберите требуемую операцию: 1 - crypt или !1 - decrypt ")
    answer = input()
    if answer=="1":
        print("Вы выбрали кодирование!")
        print("Введите строку котору требуется зашифровать: ")
        string = input()
        print("Введите ключ шифрования (24 bit): ")
        key = input()
        print("Закодированние сообщение: ")
        print(crypt(string, key))
    else:
        print("Вы выбрали декодирование!")
        print("Введите бинарную строку, которую требуется расшифровать: ")
        block = input()
        print("Введите ключ шифрования (24bit): ")
        key = input()
        print("Исходное сообщение: ")
        print(decrypt(block, key))
main()


# test:

# crypt
# input string: I_PROGRAMMER
# key: 011001110001001011010110

# decrypt
# Введите бинарную строку, которую требуется расшифровать:
# 010010010101111101011101010100100100111101000000010100100100000101000000010011010100010101010101
# Введите ключ шифрования (24bit):
# 011001110001001011010110


#manual_test

# 010010010101111101010000 - исходник
# 011001110001001011010110 - ключ
# 001011100100110110000110 - X = исх xor ключ
# 010100100100111101000111 - 2й блок
# 011111000000001011000001 - x xor 2й блок
# 011111000000001011000001 - рез кодирования 0й раунд
#
# 010100100100111101000111 - r подблок сместился влево
# 011001110001001011010110 - ключ
#
# 001101010101110110010001 - X = исх xor ключ

# 011111000000001011000001 - рез 0го раунда
# 010010010101111101010000 - рез 1й раунд
#
# 011111000000001011000001 - r подблок сместился влево
# 011001110001001011010110 - ключ
#
# 000110110001000000010111 - X = исх xor ключ
# 010010010101111101010000 - рез 1го раунда
# 010100100100111101000111 - рез 2й раунд
# 011001110001001011010110 - ключ
# 001101010101110110010001 - X = исх xor ключ
# 010010010101111101010000 - рез 1го раунда
# 011111000000001011000001 - рез 3й раунд

# БЛОК  0  ЗАКОДИРОВАН! >>> ['010100100100111101000000', '011111000000001011110011']
# ПЕРЕХОД К СЛЕДУЮЩЕМУ БЛОКУ...
# БЛОК  1  ЗАКОДИРОВАН! >>> ['010011010100010101010101', '011110000001011011111011']
# ПЕРЕХОД К СЛЕДУЮЩЕМУ БЛОКУ...

# Закодированние сообщение:
# Исходный бинарный код входного сообщения:  010010010101111101010000010100100100111101000111010100100100000101001101010011010100010101010010
# Входные бинарные блоки и их подблоки:  [['010010010101111101010000', '010100100100111101000111'], ['010100100100000101001101', '010011010100010101010010']]